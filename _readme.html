<h1>BubbleWrap for RubyMotion</h1>

<p>A collection of (tested) helpers and wrappers used to wrap CocoaTouch code and provide more Ruby like APIs.</p>

<p><a href="http://bubblewrap.io">BubbleWrap website</a><br>
<a href="https://groups.google.com/forum/#!forum/bubblewrap">BubbleWrap mailing list</a></p>

<h2>Installation</h2>

<pre lang="ruby"><code>gem install bubble-wrap
</code></pre>

<h2>Setup</h2>

<ol>
<li>Edit the <code>Rakefile</code> of your RubyMotion project and add the following require line.</li>
</ol>

<pre lang="ruby"><code>require &#39;bubble-wrap&#39;
</code></pre>

<p>BubbleWrap is split into multiple modules so that you can easily choose which parts<br>
are included at compile-time. </p>

<p>The above example requires all the wrappers/helpers. If you wish to only<br>
include the core modules use the following line of code instead:</p>

<pre lang="ruby"><code>require &#39;bubble-wrap/core&#39;
</code></pre>

<p>If you wish to only include the <code>HTTP</code> wrapper:</p>

<pre lang="ruby"><code>require &#39;bubble-wrap/http&#39;
</code></pre>

<p>Note: <strong>DON&#39;T</strong> use <code>app.files =</code> in your Rakefile to set up your files once you&#39;ve required BubbleWrap.<br>
Make sure to append onto the array or use <code>+=</code>.</p>

<ol>
<li>Now, you can use BubbleWrap extension in your app:</li>
</ol>

<pre lang="ruby"><code>class AppDelegate
  def application(application, didFinishLaunchingWithOptions:launchOptions)
    puts &quot;#{App.name} (#{documents_path})&quot;
    true
  end
end
</code></pre>

<p>Note: You can also vendor this repository but the recommended way is to<br>
use the versioned gem.</p>

<h2>Core</h2>

<h3>App</h3>

<p>A module with useful methods related to the running application</p>

<pre lang="ruby"><code>&gt; App.documents_path
# &quot;/Users/mattetti/Library/Application Support/iPhone Simulator/5.0/Applications/EEC6454E-1816-451E-BB9A-EE18222E1A8F/Documents&quot;
&gt; App.resources_path
# &quot;/Users/mattetti/Library/Application Support/iPhone Simulator/5.0/Applications/EEC6454E-1816-451E-BB9A-EE18222E1A8F/testSuite_spec.app&quot;
&gt; App.name
# &quot;testSuite&quot;
&gt; App.identifier
# &quot;io.bubblewrap.testSuite&quot;
&gt; App.alert(&quot;BubbleWrap is awesome!&quot;)
# creates and shows an alert message.
&gt; App.run_after(0.5) {  p &quot;It&#39;s #{Time.now}&quot;   }
# Runs the block after 0.5 seconds.
&gt; App::Persistence[&#39;channels&#39;] # application specific persistence storage
# [&#39;NBC&#39;, &#39;ABC&#39;, &#39;Fox&#39;, &#39;CBS&#39;, &#39;PBS&#39;]
&gt; App::Persistence[&#39;channels&#39;] = [&#39;TF1&#39;, &#39;France 2&#39;, &#39;France 3&#39;]
# [&#39;TF1&#39;, &#39;France 2&#39;, &#39;France 3&#39;]
</code></pre>

<p>Other available methods:</p>

<ul>
<li><code>App.notification_center</code></li>
<li><code>App.user_cache</code></li>
<li><code>App.states</code></li>
<li><code>App.frame</code></li>
<li><code>App.delegate</code></li>
<li><code>App.current_locale</code></li>
</ul>

<h3>Device</h3>

<p>A collection of useful methods about the current device:</p>

<p>Examples:</p>

<pre lang="ruby"><code>&gt; Device.iphone?
# true
&gt; Device.ipad?
# false
&gt; Device.front_camera?
# true
&gt; Device.rear_camera?
# true
&gt; Device.orientation
# :portrait
&gt; Device.simulator?
# true
&gt; Device.retina?
# false
&gt; Device.screen.width
# 320
&gt; Device.screen.height
# 480
&gt; Device.screen.widthForOrientation(:landscape_left)
# 480
&gt; Device.screen.heightForOrientation(:landscape_left)
# 320
</code></pre>

<h3>Gestures</h3>

<p>Extra methods on <code>UIView</code> for working with gesture recognizers. A gesture recognizer can be added using a normal Ruby block, like so:</p>

<pre lang="ruby"><code>    view.whenTapped do
      UIView.animateWithDuration(1,
        animations:lambda {
          # animate
          # @view.transform = ...
        })
    end
</code></pre>

<p>There are similar methods for pinched, rotated, swiped, panned, and pressed (for long presses). All of the methods return the actual recognizer object, so it is possible to set the delegate if more fine-grained control is needed.</p>

<h3>JSON</h3>

<p><code>BubbleWrap::JSON</code> wraps <code>NSJSONSerialization</code> available in iOS5 and offers the same API as Ruby&#39;s JSON std lib.</p>

<pre lang="ruby"><code>BW::JSON.generate({&#39;foo =&gt; 1, &#39;bar&#39; =&gt; [1,2,3], &#39;baz =&gt; &#39;awesome&#39;})
=&gt; &quot;{\&quot;foo\&quot;:1,\&quot;bar\&quot;:[1,2,3],\&quot;baz\&quot;:\&quot;awesome\&quot;}&quot;
BW::JSON.parse &quot;{\&quot;foo\&quot;:1,\&quot;bar\&quot;:[1,2,3],\&quot;baz\&quot;:\&quot;awesome\&quot;}&quot;
=&gt; {&quot;foo&quot;=&gt;1, &quot;bar&quot;=&gt;[1, 2, 3], &quot;baz&quot;=&gt;&quot;awesome&quot;}
</code></pre>

<h3>NSIndexPath</h3>

<p>Helper methods added to give <code>NSIndexPath</code> a bit more of a Ruby<br>
interface.</p>

<h3>NSNotificationCenter</h3>

<p>Helper methods to give NSNotificationCenter a Ruby-like interface:</p>

<pre lang="ruby"><code>def viewWillAppear(animated)
  @foreground_observer = notification_center.observe UIApplicationWillEnterForegroundNotification do |notification|
    loadAndRefresh
  end

  @reload_observer notification_center.observe ReloadNotification do |notification|
    loadAndRefresh
  end
end

def viewWillDisappear(animated)
  notification_center.unobserve @foreground_observer
  notification_center.unobserve @reload_observer
end

def reload
  notification_center.post ReloadNotification
end
</code></pre>

<h3>NSUserDefaults</h3>

<p>Helper methods added to the class repsonsible for user preferences used<br>
by the <code>App::Persistence</code> module shown below.</p>

<h3>Persistence</h3>

<p>Offers a way to persist application specific information using a very<br>
simple interface:</p>

<pre lang="ruby"><code>&gt; App::Persistence[&#39;channels&#39;] # application specific persistence storage
# [&#39;NBC&#39;, &#39;ABC&#39;, &#39;Fox&#39;, &#39;CBS&#39;, &#39;PBS&#39;]
&gt; App::Persistence[&#39;channels&#39;] = [&#39;TF1&#39;, &#39;France 2&#39;, &#39;France 3&#39;]
# [&#39;TF1&#39;, &#39;France 2&#39;, &#39;France 3&#39;]
</code></pre>

<h3>String</h3>

<p>The Ruby <code>String</code> class was extended to add <code>#camelize</code> and<br>
<code>#underscore</code> methods.</p>

<pre lang="ruby"><code>&gt; &quot;matt_aimonetti&quot;.camelize
=&gt; &quot;MattAimonetti&quot;
&gt; &quot;MattAimonetti&quot;.underscore
=&gt; &quot;matt_aimonetti&quot;
</code></pre>

<h3>Time</h3>

<p>The <code>Time</code> Ruby class was added a class level method to convert a<br>
iso8601 formatted string into a Time instance.</p>

<pre lang="ruby"><code>&gt; Time.iso8601(&quot;2012-05-31T19:41:33Z&quot;)
=&gt; 2012-05-31 21:41:33 +0200
</code></pre>

<h3>UIControl / UIButton</h3>

<p>Helper methods to give <code>UIButton</code> a Ruby-like interface. Ex:</p>

<pre lang="ruby"><code>button.when(UIControlEventTouchUpInside) do
  self.view.backgroundColor = UIColor.redColor
end
</code></pre>

<h3>UIViewController</h3>

<p>A custom method was added to <code>UIViewController</code> to return the content<br>
frame of a view controller.</p>

<h2>HTTP</h2>

<p><code>BubbleWrap::HTTP</code> wraps <code>NSURLRequest</code>, <code>NSURLConnection</code> and friends to provide Ruby developers with a more familiar and easier to use API.<br>
The API uses async calls and blocks to stay as simple as possible.</p>

<p>To enable it add the following require line to your <code>Rakefile</code>:</p>

<pre lang="ruby"><code>require &#39;bubble-wrap/http&#39;
</code></pre>

<p>Usage example:</p>

<pre lang="ruby"><code>BubbleWrap::HTTP.get(&quot;https://api.github.com/users/mattetti&quot;) do |response|
  p response.body.to_str
end
</code></pre>

<pre lang="ruby"><code>BubbleWrap::HTTP.get(&quot;https://api.github.com/users/mattetti&quot;, {credentials: {username: &#39;matt&#39;, password: &#39;aimonetti&#39;}}) do |response|
  p response.body.to_str # prints the response&#39;s body
end
</code></pre>

<pre lang="ruby"><code>data = {first_name: &#39;Matt&#39;, last_name: &#39;Aimonetti&#39;}
BubbleWrap::HTTP.post(&quot;http://foo.bar.com/&quot;, {payload: data}) do |response|
  if response.ok?
    json = BubbleWrap::JSON.parse(response.body.to_str)
    p json[&#39;id&#39;]
  elsif response.status_code.to_s =~ /40\d/
    alert(&quot;Login failed&quot;) # helper provided by the kernel file in this repo.
  else
    alert(response.error_message)
  end
end
</code></pre>

<p>Do you have a suggestion for a specific wrapper? Feel free to open an<br>
issue/ticket and tell us about what you are after. If you have a<br>
wrapper/helper you are using and are thinking that others might enjoy,<br>
please send a pull request (with tests if possible).</p>
